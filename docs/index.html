<!DOCTYPE html>
<html lang="en">
<HEAD>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-158202396-2"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158202396-2');
  </script>


    <meta charset="utf-8">

    <title>ActflowToolbox</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

</HEAD>

<body>
<div class="container">

<h1 id="the-brain-activity-flow-actflow-toolbox">The Brain Activity Flow (&quot;Actflow&quot;) Toolbox</h1>

<h2 id="version-0-2-2-beta-version-">Version 0.2.5 (beta)</h2>

<br>
<p>
<a class="btn btn-primary btn-lg" href="https://github.com/ColeLab/ActflowToolbox">View on GitHub</a>
</p>
<br>

<h2 id="overview">Overview</h2>

<p class="lead">This toolbox facilitates linking brain connectivity with task-evoked activity and associated cognitive/behavioral functions. The primary focus is on <em>activity flow mapping</em> and related methods (<a href="http://rdcu.be/kOJq">Cole et al. (2016)</a> & <a href="http://rdcu.be/wQ1M">Ito et al. (2017)</a>).</p>

<p class="lead">Activity flow mapping is based on core principles underlying brain network simulations, applying these principles to empirical neural/neuroimaging data. It is a highly flexible framework that is constantly being improved via better connectivity methods and creative uses of the approach to better understand brain function.</p>

<p class="lead">Activity flow mapping can be used, for instance, to infer whether one or more brain connections are involved in producing a particular function. This method can also be used to relate multiple task-evoked activations to each other (e.g., predicting one neural population's activity from another's activity). More generally, activity flow mapping can be thought of as creating <em>network coding models</em> (<a href="http://www.colelab.org/pubs/2019_ItoHearne_TiCS.pdf">Ito et al. (2020)</a>), which are empirically-constrained neural network models.</p>

<p class="lead">Other methods included in the toolbox (which can optionally be used along with activity flow mapping) are advanced versions of resting-state functional connectivity and task-state functional connectivity. The primary focus (for now) is on fMRI data, but in principle these approaches can be applied to any kind of neural data.</p>

<p class="lead">This code repository was created by the Cole Neurocognition Lab at Rutgers University: <a href="http://www.colelab.org/">http://www.colelab.org/</a>
<br>We are happy for others to contribute to the code as well.</p>

<p class="lead">See the <strong><a href="HCP_example.html">example notebook</a></strong> to see the Actflow Toolbox in action<br>
  We provide 30 subjects' data from the Human Connectome Project for trying out the toolbox</p>

<h3 id="core-algorithm-and-principles-behind-activity-flow-mapping">Core algorithm and principles behind activity flow mapping</h3>
<p class="lead">Activity flow mapping is a method validated and published in Nature Neuroscience in 2016 (see <a href="http://rdcu.be/kOJq">Cole et al. (2016)</a>), with multiple follow-up studies further validating the approach.</p>
<h4>Activity flow mapping has two basic steps:</h4>
<p>1) <em>Activity flow modeling</em>: Simulating the flow (movement) of activity between neural populations, using empirical data to estimate activity levels and routes of flow (connectivity). This is done by running the standard &quot;propagation rule&quot; and &quot;activation rule&quot; steps used in most neural network simulations (see <a href="http://www.colelab.org/pubs/2019_ItoHearne_TiCS.pdf">Ito et al. (2020)</a>). In the standard approach each neural population&#39;s activity level is predicted based on the flow from every other recorded neural population (from <a href="http://rdcu.be/kOJq">Cole et al. (2016)</a>):</p>
<p><img width="350" src="images/actflowfigure1.png"></p>
<p>2) <em>Testing prediction accuracy</em>: The predicted brain activity pattern is compared to the actual recorded activity, providing evidence for or against the activity flow model used to make the predictions. Predictions of multiple models can be compared to quantify model validity. Two examples of predicted-to-actual accuracy testing with fMRI data (from <a href="http://rdcu.be/kOJq">Cole et al. (2016)</a>):</p>
<p><img width="350" src="images/actflowfigure_predictiontesting.png"></p>
<p>In principle, any measure of neural activity and any measure of neural connectivity (e.g., structural connectivity) can be used with activity flow mapping. Some modifications are necessary for fast temporal resolution data such as EEG/MEG or multi-unit recording, but these should be available soon (we are working on it!).</p>

<h3 id="included-connectivity-mapping-methods">Included connectivity mapping methods</h3>
<ul>
<li><em>All methods can be applied to resting-state or task-state data</em></li>
<li>Correlation-based functional connectivity</li>
<li>Multiple-regression functional connectivity<ul>
<li>Ordinary least squares multiple regression connectivity</li>
<li>Regularized multiple regression connectivity<ul>
<li>Principle components regression connectivity (PCR)</li>
</ul>
</li>
</ul>
</li>
<li>Partial-correlation functional connectivity<ul>
<li>Inverse covariance-based partial correlation</li>
<li>Regularized partial correlation [planned]</li>
</ul>
</li>
<li>Causal connectivity
  <ul>
    <li>CombinedFC [planned] (see <a href="https://github.com/ColeLab/CombinedFC">https://github.com/ColeLab/CombinedFC</a>)</li>
    <li>fGES; <a href="https://doi.org/10.1007/s41060-016-0032-z">https://doi.org/10.1007/s41060-016-0032-z</a>) [planned]</li>
  </ul>
  </li>
</ul>
<h3 id="preprocessing">Preprocessing</h3>
<ul>
<li>The toolbox is compatible with existing preprocessing software such as the HCP Pipelines (<a href="https://humanconnectome.org/software/hcp-mr-pipelines/">https://humanconnectome.org/software/hcp-mr-pipelines/</a>) or fMRIPrep (<a href="https://fmriprep.readthedocs.io/en/stable/">https://fmriprep.readthedocs.io/en/stable/</a>)</li>
<li>Task functional connectivity:<ul>
<li>Finite impulse response (FIR) regressed task data is recommended, which provides flexible mean task-evoked response removal for task-state functional connectivity (<a href="http://www.colelab.org/pubs/ColeEtAl2019NeuroImage.pdf">Cole et al. (2019)</a>). See <a href="https://github.com/ColeLab/TaskFCRemoveMeanActivity">Task FC Mean Activity Removal</a> for task-state functional connectivity estimation.</li>
</ul>
</li>
<li>We recommend empirically validated nusiance regression approaches for removing fMRI data artifacts, such as for resting-state functional connectivity (or task-state functional connectivity)<ul>
<li>Example: The Ciric et al. (2017) validated preprocessing pipelines (<a href="https://www.sciencedirect.com/science/article/pii/S1053811917302288">https://www.sciencedirect.com/science/article/pii/S1053811917302288</a>)</li>
</ul>
</li>
</ul>
<h3 id="cite-as-">Cite as:</h3>
<p>
  <ol>
  <li>Cole MW, Ito T, Bassett DS, Schultz DH (2016). &quot;Activity flow over resting-state networks shapes cognitive task activations&quot;. Nature Neuroscience. 19:1718â€“1726. doi.org/10.1038/nn.4406</li>
  <li>https://colelab.github.io/ActflowToolbox/</li>
  and
  <li>The article that describes the specific toolbox functions being used in most detail</li>
  </ol>

<h2 id="how-to-install">How to install</h2>
<p>git clone --recurse-submodules https://github.com/ColeLab/ActflowToolbox.git</p>
<h2 id="email-list-forum">Email list/forum</h2>
<p>We strongly encourage you to join the ColeNeuroLab Users Group (<a href="https://groups.google.com/forum/#!forum/coleneurolab_users">https://groups.google.com/forum/#!forum/coleneurolab_users</a>), so you can be informed about major updates in this repository and others hosted by the Cole Neurocognition Lab.</p>
<h2 id="conventions">Conventions</h2>
<ul>
<li>Data matrices all node X time</li>
<li>Directed connectivity matrices all target X source</li>
<li>Primary (default) brain parcellation: CAB-NP (<a href="https://github.com/ColeLab/ColeAnticevicNetPartition">https://github.com/ColeLab/ColeAnticevicNetPartition</a>), which uses the Glasser2016 parcellation for cortex (<a href="https://balsa.wustl.edu/study/show/RVVG">https://balsa.wustl.edu/study/show/RVVG</a>) and includes an additional 358 subcortical parcels. Cortex-only analyses with only the Glasser2016 parcels are easily implemented. Other parcellations can be used, and we anticipate integrating other parcellations in the future.</li>
</ul>

<h2 id="examples">Examples</h2>
<p class="lead">A Jupyter Notebook with example analyses (and example data) is viewable here: <a href="https://github.com/ColeLab/ActflowToolbox/blob/master/examples/HCP_example.ipynb">HCP_example.ipynb</a></p>
<p>Example of calculating activity flow mapping predictions using multiple-regression FC and standard task-evoked activations with fMRI data (in Python 3; assumes task activations and resting-state fMRI data are already loaded):</p>

<pre><code><span class="hljs-keyword">import</span> ActflowToolbox <span class="hljs-keyword">as</span> actflow
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns

restFC_mreg=np.zeros((np.shape(restdata)[<span class="hljs-number">0</span>],np.shape(restdata)[<span class="hljs-number">0</span>],np.shape(restdata)[<span class="hljs-number">2</span>]))
<span class="hljs-keyword">for</span> scount <span class="hljs-built_in">in</span> np.arange(np.shape(restdata)[<span class="hljs-number">2</span>]):
    restFC_mreg[:,:,scount]=actflow.connectivity_estimation.multregconn(restdata[:,:,scount])

print(<span class="hljs-string">"==Activity flow mapping results, multiple-regression-based resting-state FC, 24 task conditions=="</span>)
actflowOutput_restFCMReg_bycond = actflow.actflowcomp.actflowtest(activations_bycond, restFC_mreg)
</code></pre><p>Output:</p>
<pre><code>==Activity flow mapping results, multiple-regression-based resting-state FC, <span class="hljs-number">24</span> task conditions==
===Comparing prediction accuracies between models (similarity between predicted <span class="hljs-keyword">and</span> actual brain activation patterns)===

==Comparisons between predicted <span class="hljs-keyword">and</span> actual activation patterns, across <span class="hljs-keyword">all</span> conditions <span class="hljs-keyword">and</span> nodes:==
<span class="hljs-comment">--Compare-then-average (calculating prediction accuracies before cross-subject averaging):</span>
Each comparison based <span class="hljs-keyword">on</span> <span class="hljs-number">24</span> conditions across <span class="hljs-number">360</span> nodes, p-values based <span class="hljs-keyword">on</span> <span class="hljs-number">30</span> subjects (cross-subject variance <span class="hljs-keyword">in</span> comparisons)

Mean Pearson r = <span class="hljs-number">0.78</span>, t-value vs. <span class="hljs-number">0</span>: <span class="hljs-number">62.27</span>, p-value vs. <span class="hljs-number">0</span>: <span class="hljs-number">1.9635597302245892e-32</span>

Mean % variance explained (R^<span class="hljs-number">2</span> score, coeff. <span class="hljs-keyword">of</span> determination) = <span class="hljs-number">0.57</span>

Mean MAE (mean absolute <span class="hljs-literal">error</span>) = <span class="hljs-number">7.54</span>

<span class="hljs-literal">Note</span>: Pearson r <span class="hljs-keyword">and</span> Pearson r^<span class="hljs-number">2</span> are scale-invariant, <span class="hljs-keyword">while</span> R^<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> MAE are <span class="hljs-keyword">not</span>. R^<span class="hljs-number">2</span> <span class="hljs-keyword">units</span>: percentage <span class="hljs-keyword">of</span> the <span class="hljs-keyword">to</span>-be-predicted data<span class="hljs-symbol">'s</span> unscaled variance, ranging from negative infinity (because prediction errors can be arbitrarily large) <span class="hljs-keyword">to</span> <span class="hljs-built_in">positive</span> <span class="hljs-number">1</span>. See https://scikit-learn.org/stable/modules/generated/sklearn.metrics.r2_score.html <span class="hljs-keyword">for</span> more info.
</code></pre>

<p>Visualizing the results:</p>
<pre><code><span class="hljs-selector-id">#Visualize</span> predicted and actual activation patterns, with multiple-regression FC
plt.figure(figsize=[<span class="hljs-number">7</span>,<span class="hljs-number">5</span>])
ax = sns.heatmap(np.mean(actflowOutput_restFCMReg_bycond[<span class="hljs-string">'actPredVector_bytask_bysubj'</span>],axis=<span class="hljs-number">2</span>)[netorder,:],center=<span class="hljs-number">0</span>,cmap=<span class="hljs-string">'seismic'</span>,cbar=True,yticklabels=<span class="hljs-number">100</span>,xticklabels=taskConditions)
ax<span class="hljs-selector-class">.figure</span><span class="hljs-selector-class">.suptitle</span>(<span class="hljs-string">'Predicted activations, multreg FC actflow'</span>)
ax.set(ylabel=<span class="hljs-string">'Regions'</span>)

plt.figure(figsize=[<span class="hljs-number">7</span>,<span class="hljs-number">5</span>])
ax = sns.heatmap(np.mean(activations_bycond,axis=<span class="hljs-number">2</span>)[netorder,:],center=<span class="hljs-number">0</span>,cmap=<span class="hljs-string">'seismic'</span>,cbar=True,yticklabels=<span class="hljs-number">100</span>,xticklabels=taskConditions)
ax<span class="hljs-selector-class">.figure</span><span class="hljs-selector-class">.suptitle</span>(<span class="hljs-string">'Actual activations (24 conditions)'</span>)
ax.set(ylabel=<span class="hljs-string">'Regions'</span>)
</code></pre><p>Output:<br></p>
<p float="left">
    <img width="350" src="images/example_multregpred.jpg"><img width="350" src="images/example_multregactual.jpg">
</p>


<h2 id="guidelinesforactflow">General guidelines for activity flow mapping</h2>
<ul>
  <li>Avoid <a href="https://wiki.biac.duke.edu/lib/exe/fetch.php?media=biac:kriegeskorte_et_al_2009.pdf">circularity</a>:
    <ul>
      <li><strong>Use connectivity independent of the to-be-predicted state when possible</strong>, such as resting-state functional connectivity. This implicitly tests for generalization across brain states (when predicting task activations), which is important given that connectivity is mostly invariant across states. There is substantial evidence for the dominant effect of intrinsic/state-general connectivity (see <a href="http://www.colelab.org/pubs/2014_Cole_Neuron.pdf">Cole et al. (2014)</a> and <a href="https://doi.org/10.1016/j.neuron.2018.03.035">Gratton et al. (2018)</a>). Using structural connectivity also avoids this issue, though some details (e.g., the aggregate effects of synaptic weights) are lost with most structural connectivity methods.</li>
      <li><strong>Ensure statistical independence of activation and functional connectivity estimates</strong> when the same state is used for estimating both. The recommended approach is to use finite impulse response (FIR) regression as a preprocessing step, removing the to-be-predicted mean task activations prior to estimating task-state functional connectivity. Note that this leaves most of the task-related variance in the time series, since mean task effects are only a small (but important; which is why we try to predict them via activity flow mapping) portion of the data. See <a href="http://www.colelab.org/pubs/ColeEtAl2019NeuroImage.pdf">Cole et al. (2019)</a> for more info.</li>
      <li><strong>Spatial smoothness of the data can introduce circularity</strong>, since this results in the same underlying neural activity being assigned to multiple spatial locations (such as multiple voxels in fMRI). We therefore recommend excluding activity flow source data within approximately 10 mm from the to-be-predicted neural signal with fMRI data (see <a href="http://rdcu.be/kOJq">Cole et al. (2016)</a>). This is less of a concern with brain region level data, since it would only apply to voxels/vertices at the border of each region. We nonetheless implemented a "non-circular" version of region-level activity analysis (excluding regions within 10 mm of the to-be-predicted region), which is demonstrated in the <a href="HCP_example.html">example notebook</a>. The vast majority of results do not change with vs. withou the "non-circular" region-level approach. Note that standard activity flow mapping should not be used with EEG/MEG or related methods at this time, since the source spread implicit in those approaches is so substantial (even when using source localization) that it would result in substantial circularity. (We are working on an approach to get around this problem, however.)</li>
    </ul>
    </li>
  <li>Compare-then-average vs. average-then-compare:
    <ul>
      <li><strong>We recommend compare-then-average statistics for most analyses</strong> (the default option in the actflowtest function). Compare-then-average compares each subject's predicted to actual activity prior to aggregating results across subjects, such that the group-level estimate is representative of individual subject results (i.e., what would be expected if the analysis was run with a new random subject). In contrast, the average-then-compare approach averages results across subjects prior to comparing predicted to actual activity. This typically boosts predicted-to-actual similarity due to more data being included in both the predicted and actual estimates, as well as due to "bluring"/smoothing the data from cross-subject averaging. It also prevents computation of meaningful p-values, since there is no inter-subject variance in prediction accuracy to use for t-tests and similar approaches. Note, however, that visualizing group results (plotting predicted and actual activation patterns next to each other) effectively results in the average-then-compare approach, since results are averaged prior to the reader comparing the results by eye. Thus, predicted-to-actual similarity typically appears higher in these plots than they are at the individual subject level.
    </ul>
    </li>
</ul>
<p>

<h2 id="software-development-guidelines">Software development guidelines</h2>
<ul>
<li>Primary language: Python 3</li>
<li>Secondary language (for select functions, minimally maintained/updated): MATLAB</li>
<li>Versioning guidelines: Semantic Versioning 2.0.0 (<a href="https://semver.org/">https://semver.org/</a>); used loosely prior to v1.0.0, strictly after</li>
<li>Using GitHub for version control<ul>
<li>Those new to Git should go through a tutorial for branching, etc.: <a href="https://www.youtube.com/watch?v=oFYyTZwMyAg">https://www.youtube.com/watch?v=oFYyTZwMyAg</a> and <a href="https://guides.github.com/activities/hello-world/">https://guides.github.com/activities/hello-world/</a></li>
<li>Use branching for adding new features, making sure code isn&#39;t broken by changes</li>
<li>Considering using unit tests and Travis CI (<a href="https://travis-ci.org">https://travis-ci.org</a>) in future</li>
</ul>
</li>
<li>Style specifications:<ul>
<li>PEP8 style as general guidelines (loosely applied for now): <a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></li>
<li>Soft tabs (4 spaces) for indentations [ideally set &quot;soft tabs&quot; setting in editor, so pressing tab key produces 4 spaces]</li>
<li>Use intuitive variable and function names</li>
<li>Add detailed comments to explain what code does (especially when not obvious)</li>
</ul>
</li>
</ul>
<h2 id="publications-that-have-used-activity-flow-mapping-and-or-this-toolbox">Publications that have used activity flow mapping and/or this toolbox</h2>
<ul>
<li>Cole MW, Ito T, Bassett DS, Schultz DH (2016). &quot;Activity flow over resting-state networks shapes cognitive task activations&quot;. Nature Neuroscience. 19:1718â€“1726.<a href="http://dx.doi.org/10.1038/nn.4406">http://dx.doi.org/10.1038/nn.4406</a></li>
<li>Ito T, Kulkarni KR, Schultz DH, Mill RD, Chen RH, Solomyak LI, Cole MW (2017). &quot;Cognitive task information is transferred between brain regions via resting-state network topology&quot;. Nature Communications. 8:1027. <a href="http://dx.doi.org/10.1038/s41467-017-01000-w">http://dx.doi.org/10.1038/s41467-017-01000-w</a></li>
<li>Mill RD, Gordon BA, Balota DA, Zacks JM, Cole MW (Preprint). &quot;Predicting dysfunctional age-related task activations from resting-state network alterations&quot;. bioRxiv. <a href="https://doi.org/10.1101/678086">https://doi.org/10.1101/678086</a></li>
</ul>
<h2 id="other-related-tools">Other related tools</h2>
<ul>
<li><a href="https://github.com/ColeLab/informationtransfermapping">Information transfer mapping</a></li>
<li><a href="https://github.com/ColeLab/TaskFCRemoveMeanActivity">Task FC Mean Activity Removal</a> for task-state functional connectivity estimation</li>
<li><a href="https://github.com/ColeLab/ColeAnticevicNetPartition">The Cole-Anticevic Brain-wide Network Partition (CAB-NP)</a></li>
<li><a href="http://www.colelab.org/#resources">Other tools released by the Cole Neurocognition Lab</a></li>
</ul>
<h2 id="contents">Contents</h2>
<ul>
<li><em>Directory</em>: actflowcomp - Calculating activity flow mapping<ul>
<li>actflowcalc.py - Main function for calculating activity flow mapping predictions</li>
<li>actflowtest.py - A convenience function for calculating activity-flow-based predictions and testing prediction accuracies (across multiple subjects)</li>
<li>noiseceilingcalc.py - A convenience function for calculating the theoretical limit on activity-flow-based prediction accuracies (based on noise in the data being used)</li>
</ul>
</li>
<li><em>Directory</em>: connectivity_estimation - Connectivity estimation methods<ul>
<li>calcactivity_parcelwise_noncircular_surface.py: High-level function for calculating parcelwise actflow with parcels that are touching (e.g., the Glasser 2016 parcellation), focusing on task activations. This can create circularity in the actflow predictions due to spatial autocorrelation. This function excludes vertices within X mm (10 mm by default) of each to-be-predicted parcel.</li>
<li>calcconn_parcelwise_noncircular_surface.py: High-level function for calculating parcelwise actflow with parcels that are touching (e.g., the Glasser 2016 parcellation), focusing on connectivity estimation. This can create circularity in the actflow predictions due to spatial autocorrelation. This function excludes vertices within X mm (10 mm by default) of each to-be-predicted parcel.</li>
<li>corrcoefconn.py: Calculation of Pearson correlation functional connectivity</li>
<li>multregconn.py: Calculation of multiple-regression functional connectivity</li>
<li>partial_corrconn.py: Calculation of partial-correlation functional connectivity</li>
<li>pc_multregconn.py: Calculation of regularized multiple-regression functional connectivity using principle components regression (PCR). Useful when there are fewer time points than nodes, for instance.</li>
</ul>
</li>
<li><em>Directory</em>: dependencies - Other packages Actflow Toolbox depends on</li>
<li><em>Directory</em>: examples - Example analyses that use the Actflow Toolbox (Jupyter notebook)</li>
<li><em>Directory</em>: matlab_code - Limited functions for activity flow mapping in MATLAB<ul>
<li>PCmultregressionconnectivity.m - Compute multiple regression-based functional connectivity; PC allows for more regions/voxels than time points. </li>
<li>actflowmapping.m - MATLAB version of actflowcalc.py; Main function for computing activity flow mapping predictions</li>
<li>multregressionconnectivity.m - Compute multiple regrression-based functional connectivity</li>
</ul>
</li>
<li><em>Directory</em>: model_compare - Comparing prediction accuracies across models<ul>
<li>model_compare_predicted_to_actual.py - Calculation of predictive model performance</li>
<li>model_compare.py - Reporting of model prediction performance, and comparison of prediction performance across models</li>
</ul>
</li>
<li><em>Directory</em>: network_definitions - Data supporting parcel/region sets and network definitions<ul>
<li>dilateParcels.py - Dilate individual parcels (cortex and subcortex) and produce masks to exclude vertices within 10 mm; requires Connectome workbench</li>
</ul>
</li>
<li><em>Directory</em>: simulations - Simulations used for validating methods </li>
<li><em>Directory</em>: tools - Miscellaneous tools<ul>
<li>addNetColors.py - Generates a heatmap figure with The Cole-Anticevic Brain-wide Network Partition (CAB-NP) colors along axes</li>
<li>addNetColors_Seaborn.py - Generates a Seaborn heatmap figure with The Cole-Anticevic Brain-wide Network Partition (CAB-NP) colors along axes</li>
<li>map_to_surface.py - Maps 2D matrix data onto a dscalar surface file (64k vertices); uses Glasser et al. 2016 ROI parcellation</li>
<li>max_r.py - Permutation testing to control for FWE (as in Nichols &amp; Holmes, 2002 max-t); individual difference correlations (r)</li>
<li>max_t.py - Permutation testing to control for FWE (as in Nichols &amp; Holmes, 2002); t-test variants (t)</li>
<li>regression.py - Compute multiple linear regression (with L2 regularization option)</li>
</ul>
</li>
</ul>

</div>

<!-- Default Statcounter code for ActflowToolbox
https://colelab.github.io/ActflowToolbox/ -->
<script type="text/javascript">
var sc_project=12208539;
var sc_invisible=1;
var sc_security="a78ed7d0";
var sc_https=1;
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js" async></script>
<noscript><div class="statcounter"><a title="Web Analytics Made Easy -
StatCounter" href="https://statcounter.com/" target="_blank"><img
class="statcounter" src="https://c.statcounter.com/12208539/0/a78ed7d0/1/"
alt="Web Analytics Made Easy - StatCounter"></a></div></noscript>
<!-- End of Statcounter Code -->

</body>
